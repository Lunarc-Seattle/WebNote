
# 📑 目录

- [📑 目录](#-目录)
  - [Basic JavaScript](#basic-javascript)
    - [JavaScript 基础](#javascript-基础)
      - [循环与条件](#循环与条件)
      - [变量声明](#变量声明)
    - [Node.js 基础](#nodejs-基础)
      - [导入和导出 **export** 用法](#导入和导出-export-用法)
      - [安装与卸载依赖](#安装与卸载依赖)
      - [更新与查看依赖](#更新与查看依赖)
      - [运行脚本与发布包](#运行脚本与发布包)
    - [Node.js 运行与调试](#nodejs-运行与调试)
    - [关于 `node_modules`](#关于-node_modules)
    - [JSON 格式](#json-格式)
    - [package.json scripts 作用](#packagejson-scripts-作用)
      - [基本结构](#基本结构)
      - [常见用途](#常见用途)
  - [package-lock.json 详解](#package-lockjson-详解)
    - [`package-lock.json` 是什么？](#package-lockjson-是什么)
    - [`package-lock.json` 的作用](#package-lockjson-的作用)
    - [`package-lock.json` 和 `package.json` 的区别](#package-lockjson-和-packagejson-的区别)
    - [`package-lock.json` 不需要放进 `node_modules/` ！！！不要手动放进 `node_modules/`](#package-lockjson-不需要放进-node_modules-不要手动放进-node_modules)
    - [`package-lock.json` 的正确位置：](#package-lockjson-的正确位置)
    - [为什么不放进 `node_modules/`？](#为什么不放进-node_modules)
  - [版本控制（Semantic Versioning）](#版本控制semantic-versioning)
    - [精确版本（Exact Version）](#精确版本exact-version)
    - [次要版本更新（Latest of This Major Version）](#次要版本更新latest-of-this-major-version)
    - [`~x.y.z`（最新的补丁版本，Latest of This Minor Version）](#xyz最新的补丁版本latest-of-this-minor-version)
    - [总结对比](#总结对比)
  - [静态资源与 Express 路由](#静态资源与-express-路由)
    - [静态资源管理](#静态资源管理)
    - [Express 路由](#express-路由)
  - [Express.js 静态资源与路由总结](#expressjs-静态资源与路由总结)
      - [1. `/public` 作为静态资源的根目录（Document Root）](#1-public-作为静态资源的根目录document-root)
      - [2. **静态资源的引用**](#2-静态资源的引用)
      - [3. **创建与确认静态资源**](#3-创建与确认静态资源)
      - [4. **静态资源 vs. 动态资源**](#4-静态资源-vs-动态资源)
      - [5. **Express 路由（Routes）**](#5-express-路由routes)
      - [6. **Express 处理请求流程**](#6-express-处理请求流程)

---

## Basic JavaScript

### JavaScript 基础

#### 循环与条件
- 推荐使用 `for...of` 代替索引循环。
- `0` 是 falsy 值。
- 避免使用 `==`(loose comparison)，推荐使用 `===` 进行严格比较。

#### 变量声明
- 使用 `let` 和 `const` 代替 `var`。
- `let` 用于可变的变量，`const` 用于不可变的常量。

### Node.js 基础

#### 导入和导出 **export** 用法
- 1导出对象：export object
  ```js
  const foo = require('./foo').cat;
  ```
  // foo 的值是 "Meow"
  解释：
  ```js
  foo.js里
  module.exports = {
      cat: "Meow",
      dog: "Woof"
  };
  require('./foo') 导入 `foo.js` 模块，该模块导出了一个对象。
  .cat 获取导出对象中的 `cat` 属性。
  `foo` 的值是 `foo.js` 中 `cat` 属性的值。
  ```
- 2：export function
  ```javascript
  const bar = require('./bar')();
  ```
  解释
  ``` 如果 bar.js 导出一个函数，require('./bar')() 会执行该函数并将其返回值赋给 bar
  如果 bar.js 导出的是一个对象或其他值，直接使用 
  - require('./bar') 即可，不需要加 ()
  - require 是 Node.js 用来加载模块的方法
  ./bar 表示当前目录下的 bar.js 文件（.js 扩展名可以省略）。

  - require('./bar') 会加载 bar.js 模块，并返回该模块导出的内容。
  require('./bar')():

  如果 bar.js 导出一个函数，那么 require('./bar') 返回的就是这个函数。后面的 () 表示立即调用这个函数。

  函数执行后，其返回值会被赋给 bar 变量。

  const bar = ...:
  将函数执行后的返回值赋给 bar 变量。
  const 表示 bar 是一个常量，不能被重新赋值
- 3 导出对象 export object:
  const { onePart, somePart } = require('./baz');

#### 命名规范
- 🔴 变量：`camelCase`
- 🔴 类或构造函数：`MixedCase`

---

## NPM 与 Node.js 工具

### NPM 常用操作

#### 初始化项目
```bash
npm init
npm init -y
```

#### 安装与卸载依赖
```bash
npm install <package-name>
npm uninstall <package-name>
```

#### 更新与查看依赖
```bash
npm update
npm list
```


#### 运行脚本与发布包
```bash
npm run <script-name>
npm publish
```

### Node.js 运行与调试
- 运行服务器脚本：
  ```bash
  node server.js
  ```
  使用 `Ctrl + C` 结束。

### 关于 `node_modules`
- 你不需要在 `git push` 时包含 `node_modules` 文件夹，它会占用大量空间。
- 使用 `npm install` 可以根据 `package.json` 自动安装依赖。

###  JSON 格式
- JSON 是一种列出结构化数据的文本格式。
- ```A text format listing structured data ```


### package.json scripts 作用

`package.json` 中的 `scripts` 字段用于定义可执行的 npm 命令，简化项目的管理和自动化操作。

#### 基本结构
```json
{
  "scripts": {
    "start": "node index.js",
    "test": "jest",
    "dev": "nodemon index.js"
  }
}
```

#### 常见用途
- 启动应用：`npm start`
- 开发模式：`npm run dev`
- 运行测试：`npm test`

---

## package-lock.json 详解
### `package-lock.json` 是什么？
`package-lock.json` 是 **NPM（Node.js 包管理器）** 自动生成的一个文件，它的主要作用是**锁定依赖版本**，确保团队或部署环境安装的依赖一致。

###  `package-lock.json` 的作用
1. **锁定依赖版本**  
   - `package.json` 允许 `"^1.0.0"` 或 `"~1.0.0"` 这样的范围版本，可能导致不同环境安装的版本不一致。  
   - `package-lock.json` 记录了**每个包的确切版本**，确保 `npm install` 安装的版本始终一致。

2. **加快安装速度**  
   - `npm install` 时会先查 `package-lock.json`，如果已存在**锁定的版本**，就不会重复解析 `package.json`，从而提高安装速度。

3. **确保团队和生产环境一致**  
   - 在多人协作或 CI/CD（持续集成/持续部署）时，`package-lock.json` 确保所有人安装的依赖版本一致，避免“本地能跑，服务器报错”的情况。

### `package-lock.json` 和 `package.json` 的区别
| 文件 | 作用 |
|------|------|
| `package.json` | 记录项目的**依赖信息**，但**可能允许版本浮动**（`^`、`~`） |
| `package-lock.json` | 记录**精确的依赖版本**，防止安装不同的版本 |

###  `package-lock.json` 不需要放进 `node_modules/` ！！！不要手动放进 `node_modules/`

### `package-lock.json` 的正确位置：
- 放在**项目根目录**，与 `package.json` **同级**，而不是 `node_modules/` 里。
- 不要手动放入 `node_modules/`。
### 为什么不放进 `node_modules/`？
1. **`node_modules/` 里存的是依赖包，不是配置文件**
   - `node_modules/` 目录由 `npm install` 生成，它存放的是实际的依赖包，而 `package-lock.json` 只是**记录依赖版本**的文件，不属于 `node_modules/`。

---

## 版本控制（Semantic Versioning）

在 npm（Node Package Manager）中，版本号遵循 **语义化版本（Semantic Versioning，简称 SemVer）** 规则：  
`x.y.z` 代表版本号，其中：
- `x`（major）：主版本号（重大更新，可能不兼容旧版本）
- `y`（minor）：次版本号（添加新功能，向后兼容）
- `z`（patch）：补丁版本号（修复 bug，向后兼容）

### 精确版本（Exact Version）
```json
"package-name": "1.2.3"
```
解释：  
`1.2.3` 固定版本，必须安装完全相同的版本 `1.2.3`，不会自动升级。

举例：
```json
"react": "18.2.0"
```
只会安装 `18.2.0`，不会更新到 `18.2.1` 或 `19.0.0`。



### 次要版本更新（Latest of This Major Version）
`^x.y.z`（最新的次要版本，Latest of This Major Version）

格式：
```json
"package-name": "^1.2.3"
```
解释：  
允许更新补丁（patch）和次要版本（minor），但不更新主版本（major）。  
可以安装 `1.2.4`, `1.3.0`, `1.9.9`，但不会升级到 `2.0.0`。

举例：
```json
"lodash": "^4.17.21"
```
可能安装 `4.17.22` 或 `4.18.0`，但不会升级到 `5.0.0`。

英文读法：
"***Caret*** one dot two dot three."


### `~x.y.z`（最新的补丁版本，Latest of This Minor Version）

格式：
```json
"package-name": "~1.2.3"
```
解释：  
允许更新补丁（patch），但不能更新次要版本（minor）或主版本（major）。  
可以安装 `1.2.4` 或 `1.2.9`，但不会升级到 `1.3.0` 或 `2.0.0`。

举例：
```json
"express": "~4.16.1"
```
可能安装 `4.16.2`，但不会升级到 `4.17.0` 或 `5.0.0`。

英文读法：
"***Tilde*** one dot two dot three."


### 总结对比
| 符号  | 作用 |
|------|------|
| `1.2.3`  | 精确版本 |
| `^1.2.3` | 允许小版本更新 |
| `~1.2.3` | 允许补丁更新 |

---

## 静态资源与 Express 路由

### 静态资源管理
- `/public` 是静态资源的根目录。
- 引用静态资源时不需要带 `public/`

### Express 路由
- 路由由 `Method + Path` 组成。
- Express 会匹配请求并调用对应的回调函数。

---

## Express.js 静态资源与路由总结

#### 1. `/public` 作为静态资源的根目录（Document Root）
- `public/` 目录用于存放 **静态资源**（HTML、CSS、JS、图片等）。
- `express.static('public')` 使 `public/` 目录成为 Web 服务器的**根目录**：
  - 服务器会自动暴露 `public/` 内的文件。
  - **服务器代码不会被暴露**，提高安全性。

#### 2. **静态资源的引用**
- **不需要在 URL 中加 `public/`**，直接从 `/` 开始引用：
  ```html
  <link rel="stylesheet" href="/css/styles.css">
  ```
  - 服务器会找到 `public/css/styles.css` 并返回它。
  - **相对路径也可以使用**。

#### 3. **创建与确认静态资源**
- 目录结构：
  ```
  public/
  ├── index.html
  ├── css/
  │   ├── styles.css
  ├── images/
  │   ├── logo.png
  ```
- 运行服务器：
  ```bash
  node server.js
  ```
- 访问：
  - `http://localhost:3000/` 加载 `public/index.html`
  - `http://localhost:3000/css/styles.css` 加载 CSS 文件

#### 4. **静态资源 vs. 动态资源**
| 类型 | 说明 |
|------|------|
| **静态资源（Static Asset）** | 服务器上已有的文件（HTML、CSS、JS、图片）。 |
| **动态资源（Dynamic Asset）** | 服务器处理后生成的内容，如 API 返回的 JSON 或动态渲染的 HTML。 |

#### 5. **Express 路由（Routes）**
- **路由 = HTTP 方法 + URL 路径**：
  ```js
  app.get('/home', (req, res) => {
      res.send('Welcome to Home Page');
  });
  ```
- **工作方式**：
  1. Express 遍历所有定义的路由。
  2. 找到 **第一个匹配的路由** 并执行回调函数。
  3. 如果没有匹配的路由，返回 404。

#### 6. **Express 处理请求流程**
1. **客户端请求**（如 `GET /home`）。
2. **Express 查找匹配的路由**。
3. **执行回调函数** 并发送响应。
4. **如果没有匹配的路由，返回 404**。

---

**总结**：
- **静态资源在 `public/` 内，不需要写 `public/` 在 URL 里。**
- **Express 先匹配路由，找到第一个匹配的就执行，不再继续查找。**
- **静态资源是服务器直接返回的文件，动态资源是服务器计算后返回的内容。**

🚀 **确认服务器是否正常运行**：
```bash
node server.js
```
然后访问 `http://localhost:3000/` 进行测试。

